// Задача: Проверка анаграмм
// Напиши функцию, которая принимает два слова и проверяет, являются ли они анаграммами. Анаграммы — это слова, которые содержат одинаковые буквы в одинаковом количестве, но в разном порядке (например, "listen" и "silent").

// Условия:

// Игнорируйте пробелы и регистр символов.
// Важно, чтобы количество каждого символа в одном слове совпадало с количеством в другом.
// javascript
// Копировать код
// function areAnagrams(str1, str2) {
//   // Твоя реализация
// }
// Пример:
// javascript
// Копировать код
// areAnagrams("listen", "silent"); // true
// areAnagrams("hello", "world");   // false
// areAnagrams("Racecar", "cArEcAr"); // true
// Подсказка:
// Преобразуй обе строки в нижний регистр и убери пробелы.
// Используй методы для подсчета символов или сортировку строк и сравнение их.

// 2/2

// Вы сказали:
// дай сложную
// ChatGPT сказал:
// ChatGPT
// Вот более сложная задача, связанная с анаграммами:

// Задача: Группировка анаграмм
// Напиши функцию, которая принимает массив строк и группирует их в массивы анаграмм. То есть, все строки, которые являются анаграммами, должны быть сгруппированы в один массив.

// Условия:

// Каждая группа анаграмм должна быть представлена как массив.
// Массив анаграмм должен быть возвращен в виде массива этих групп.
// Игнорируйте регистр символов.
// Строки в группах могут быть в любом порядке.
// javascript
// Копировать код
// function groupAnagrams(strs) {
//   // Твоя реализация
// }
// Пример:
// javascript
// Копировать код
// groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]);
// // Вывод: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
// Подсказка:
// Один из способов решения задачи — это использование объекта или карты (Map) для хранения групп анаграмм. Ключом может быть отсортированная версия строки, а значением — массив всех строк, которые являются анаграммами.
// Алгоритм должен быть эффективным, учитывая возможные большие объемы данных.
// Пояснение:
// Для каждой строки вычисляется "ключ" — отсортированная версия строки.
// Все строки с одинаковым ключом помещаются в одну группу (массив).
// В конце возвращается массив всех групп анаграмм.
// Этот подход позволяет эффективно группировать анаграммы с помощью использования хеширования.



// Вот еще более сложная задача, которая касается поиска анаграмм в контексте больших данных или текстов:

// Задача: Поиск всех анаграмм в строке
// Напиши функцию, которая принимает строку s и строку p, и возвращает все начальные индексы в строке s, начиная с которых можно найти анаграмму строки p. То есть, в строке s нужно найти все подстроки, которые являются анаграммами строки p.

// Условия:

// Необходимо использовать эффективный алгоритм, который не использует сортировку для каждой подстроки.
// Подстрока должна быть точной анаграммой, включая одинаковую длину.
// Все индексы, на которых начинаются такие подстроки, должны быть возвращены.
// javascript
// Копировать код
// function findAnagrams(s, p) {
//   // Твоя реализация
// }
// Пример:
// javascript
// Копировать код
// findAnagrams("cbaebabacd", "abc");
// // Вывод: [0, 6]

// findAnagrams("abab", "ab");
// // Вывод: [0, 1, 2]
// Подсказка:
// Для решения задачи можно использовать скользящее окно (sliding window) и сравнение частот символов.
// Создайте массив для отслеживания частот символов строки p и для текущего окна в строке s.
// Когда окно находит анаграмму, запишите текущую позицию.
// Пояснение:
// Строка p фиксирована, и мы ищем ее анаграммы в строке s.
// Мы используем скользящее окно длины p.length, чтобы проверить все возможные подстроки в строке s той же длины.
// Вместо того чтобы сортировать каждый раз, можно отслеживать частоты символов в окне и сравнивать их с частотами в строке p.
// Если частоты совпадают, значит, текущая подстрока — это анаграмма.
// Алгоритм:
// Создайте массив для частот символов в строках p и для текущего окна в s.
// Применяйте скользящее окно, двигаясь по строке s.
// Когда окно будет сдвигаться, обновляйте частоты символов и сравнивайте с частотами в строке p.
// Если частоты совпадают, добавляйте индекс начала окна в результат.
// Этот подход является более эффективным, чем сортировка подстрок, и имеет сложность O(n), где n — длина строки s, что значительно ускоряет решение по сравнению с методом сортировки каждого окна.